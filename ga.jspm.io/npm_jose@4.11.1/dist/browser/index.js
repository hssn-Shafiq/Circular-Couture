var e=crypto;const isCryptoKey=e=>e instanceof CryptoKey;const digest=async(t,r)=>{const n=`SHA-${t.slice(-3)}`;return new Uint8Array(await e.subtle.digest(n,r))};const t=new TextEncoder;const r=new TextDecoder;const n=2**32;function concat(...e){const t=e.reduce(((e,{length:t})=>e+t),0);const r=new Uint8Array(t);let n=0;e.forEach((e=>{r.set(e,n);n+=e.length}));return r}function p2s(e,r){return concat(t.encode(e),new Uint8Array([0]),r)}function writeUInt32BE(e,t,r){if(t<0||t>=n)throw new RangeError(`value must be >= 0 and <= ${n-1}. Received ${t}`);e.set([t>>>24,t>>>16,t>>>8,255&t],r)}function uint64be(e){const t=Math.floor(e/n);const r=e%n;const a=new Uint8Array(8);writeUInt32BE(a,t,0);writeUInt32BE(a,r,4);return a}function uint32be(e){const t=new Uint8Array(4);writeUInt32BE(t,e);return t}function lengthAndInput(e){return concat(uint32be(e.length),e)}async function concatKdf(e,t,r){const n=Math.ceil((t>>3)/32);const a=new Uint8Array(32*n);for(let t=0;t<n;t++){const n=new Uint8Array(4+e.length+r.length);n.set(uint32be(t+1));n.set(e,4);n.set(r,4+e.length);a.set(await digest("sha256",n),32*t)}return a.slice(0,t>>3)}const encodeBase64=e=>{let r=e;"string"===typeof r&&(r=t.encode(r));const n=32768;const a=[];for(let e=0;e<r.length;e+=n)a.push(String.fromCharCode.apply(null,r.subarray(e,e+n)));return btoa(a.join(""))};const encode$1=e=>encodeBase64(e).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_");const decodeBase64=e=>{const t=atob(e);const r=new Uint8Array(t.length);for(let e=0;e<t.length;e++)r[e]=t.charCodeAt(e);return r};const decode$1=e=>{let t=e;t instanceof Uint8Array&&(t=r.decode(t));t=t.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"");try{return decodeBase64(t)}catch(e){throw new TypeError("The input to be decoded is not correctly encoded.")}};class JOSEError extends Error{constructor(e){var t;super(e);this.code="ERR_JOSE_GENERIC";this.name=this.constructor.name;null===(t=Error.captureStackTrace)||void 0===t?void 0:t.call(Error,this,this.constructor)}static get code(){return"ERR_JOSE_GENERIC"}}class JWTClaimValidationFailed extends JOSEError{constructor(e,t="unspecified",r="unspecified"){super(e);this.code="ERR_JWT_CLAIM_VALIDATION_FAILED";this.claim=t;this.reason=r}static get code(){return"ERR_JWT_CLAIM_VALIDATION_FAILED"}}class JWTExpired extends JOSEError{constructor(e,t="unspecified",r="unspecified"){super(e);this.code="ERR_JWT_EXPIRED";this.claim=t;this.reason=r}static get code(){return"ERR_JWT_EXPIRED"}}class JOSEAlgNotAllowed extends JOSEError{constructor(){super(...arguments);this.code="ERR_JOSE_ALG_NOT_ALLOWED"}static get code(){return"ERR_JOSE_ALG_NOT_ALLOWED"}}class JOSENotSupported extends JOSEError{constructor(){super(...arguments);this.code="ERR_JOSE_NOT_SUPPORTED"}static get code(){return"ERR_JOSE_NOT_SUPPORTED"}}class JWEDecryptionFailed extends JOSEError{constructor(){super(...arguments);this.code="ERR_JWE_DECRYPTION_FAILED";this.message="decryption operation failed"}static get code(){return"ERR_JWE_DECRYPTION_FAILED"}}class JWEInvalid extends JOSEError{constructor(){super(...arguments);this.code="ERR_JWE_INVALID"}static get code(){return"ERR_JWE_INVALID"}}class JWSInvalid extends JOSEError{constructor(){super(...arguments);this.code="ERR_JWS_INVALID"}static get code(){return"ERR_JWS_INVALID"}}class JWTInvalid extends JOSEError{constructor(){super(...arguments);this.code="ERR_JWT_INVALID"}static get code(){return"ERR_JWT_INVALID"}}class JWKInvalid extends JOSEError{constructor(){super(...arguments);this.code="ERR_JWK_INVALID"}static get code(){return"ERR_JWK_INVALID"}}class JWKSInvalid extends JOSEError{constructor(){super(...arguments);this.code="ERR_JWKS_INVALID"}static get code(){return"ERR_JWKS_INVALID"}}class JWKSNoMatchingKey extends JOSEError{constructor(){super(...arguments);this.code="ERR_JWKS_NO_MATCHING_KEY";this.message="no applicable key found in the JSON Web Key Set"}static get code(){return"ERR_JWKS_NO_MATCHING_KEY"}}class JWKSMultipleMatchingKeys extends JOSEError{constructor(){super(...arguments);this.code="ERR_JWKS_MULTIPLE_MATCHING_KEYS";this.message="multiple matching keys found in the JSON Web Key Set"}static get code(){return"ERR_JWKS_MULTIPLE_MATCHING_KEYS"}}class JWKSTimeout extends JOSEError{constructor(){super(...arguments);this.code="ERR_JWKS_TIMEOUT";this.message="request timed out"}static get code(){return"ERR_JWKS_TIMEOUT"}}class JWSSignatureVerificationFailed extends JOSEError{constructor(){super(...arguments);this.code="ERR_JWS_SIGNATURE_VERIFICATION_FAILED";this.message="signature verification failed"}static get code(){return"ERR_JWS_SIGNATURE_VERIFICATION_FAILED"}}var a=Object.freeze(Object.defineProperty({__proto__:null,JOSEError:JOSEError,JWTClaimValidationFailed:JWTClaimValidationFailed,JWTExpired:JWTExpired,JOSEAlgNotAllowed:JOSEAlgNotAllowed,JOSENotSupported:JOSENotSupported,JWEDecryptionFailed:JWEDecryptionFailed,JWEInvalid:JWEInvalid,JWSInvalid:JWSInvalid,JWTInvalid:JWTInvalid,JWKInvalid:JWKInvalid,JWKSInvalid:JWKSInvalid,JWKSNoMatchingKey:JWKSNoMatchingKey,JWKSMultipleMatchingKeys:JWKSMultipleMatchingKeys,JWKSTimeout:JWKSTimeout,JWSSignatureVerificationFailed:JWSSignatureVerificationFailed},Symbol.toStringTag,{value:"Module"}));var i=e.getRandomValues.bind(e);function bitLength$1(e){switch(e){case"A128GCM":case"A128GCMKW":case"A192GCM":case"A192GCMKW":case"A256GCM":case"A256GCMKW":return 96;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":return 128;default:throw new JOSENotSupported(`Unsupported JWE Algorithm: ${e}`)}}var generateIv=e=>i(new Uint8Array(bitLength$1(e)>>3));const checkIvLength=(e,t)=>{if(t.length<<3!==bitLength$1(e))throw new JWEInvalid("Invalid Initialization Vector length")};const checkCekLength=(e,t)=>{const r=e.byteLength<<3;if(r!==t)throw new JWEInvalid(`Invalid Content Encryption Key length. Expected ${t} bits, got ${r} bits`)};const timingSafeEqual=(e,t)=>{if(!(e instanceof Uint8Array))throw new TypeError("First argument must be a buffer");if(!(t instanceof Uint8Array))throw new TypeError("Second argument must be a buffer");if(e.length!==t.length)throw new TypeError("Input buffers must have the same length");const r=e.length;let n=0;let a=-1;while(++a<r)n|=e[a]^t[a];return 0===n};function isCloudflareWorkers(){return"undefined"!==typeof WebSocketPair||"undefined"!==typeof navigator&&"Cloudflare-Workers"===navigator.userAgent||"undefined"!==typeof EdgeRuntime&&"vercel"===EdgeRuntime}function unusable(e,t="algorithm.name"){return new TypeError(`CryptoKey does not support this operation, its ${t} must be ${e}`)}function isAlgorithm(e,t){return e.name===t}function getHashLength(e){return parseInt(e.name.slice(4),10)}function getNamedCurve$1(e){switch(e){case"ES256":return"P-256";case"ES384":return"P-384";case"ES512":return"P-521";default:throw new Error("unreachable")}}function checkUsage(e,t){if(t.length&&!t.some((t=>e.usages.includes(t)))){let e="CryptoKey does not support this operation, its usages must include ";if(t.length>2){const r=t.pop();e+=`one of ${t.join(", ")}, or ${r}.`}else 2===t.length?e+=`one of ${t[0]} or ${t[1]}.`:e+=`${t[0]}.`;throw new TypeError(e)}}function checkSigCryptoKey(e,t,...r){switch(t){case"HS256":case"HS384":case"HS512":{if(!isAlgorithm(e.algorithm,"HMAC"))throw unusable("HMAC");const r=parseInt(t.slice(2),10);const n=getHashLength(e.algorithm.hash);if(n!==r)throw unusable(`SHA-${r}`,"algorithm.hash");break}case"RS256":case"RS384":case"RS512":{if(!isAlgorithm(e.algorithm,"RSASSA-PKCS1-v1_5"))throw unusable("RSASSA-PKCS1-v1_5");const r=parseInt(t.slice(2),10);const n=getHashLength(e.algorithm.hash);if(n!==r)throw unusable(`SHA-${r}`,"algorithm.hash");break}case"PS256":case"PS384":case"PS512":{if(!isAlgorithm(e.algorithm,"RSA-PSS"))throw unusable("RSA-PSS");const r=parseInt(t.slice(2),10);const n=getHashLength(e.algorithm.hash);if(n!==r)throw unusable(`SHA-${r}`,"algorithm.hash");break}case isCloudflareWorkers()&&"EdDSA":if(!isAlgorithm(e.algorithm,"NODE-ED25519"))throw unusable("NODE-ED25519");break;case"EdDSA":if("Ed25519"!==e.algorithm.name&&"Ed448"!==e.algorithm.name)throw unusable("Ed25519 or Ed448");break;case"ES256":case"ES384":case"ES512":{if(!isAlgorithm(e.algorithm,"ECDSA"))throw unusable("ECDSA");const r=getNamedCurve$1(t);const n=e.algorithm.namedCurve;if(n!==r)throw unusable(r,"algorithm.namedCurve");break}default:throw new TypeError("CryptoKey does not support this operation")}checkUsage(e,r)}function checkEncCryptoKey(e,t,...r){switch(t){case"A128GCM":case"A192GCM":case"A256GCM":{if(!isAlgorithm(e.algorithm,"AES-GCM"))throw unusable("AES-GCM");const r=parseInt(t.slice(1,4),10);const n=e.algorithm.length;if(n!==r)throw unusable(r,"algorithm.length");break}case"A128KW":case"A192KW":case"A256KW":{if(!isAlgorithm(e.algorithm,"AES-KW"))throw unusable("AES-KW");const r=parseInt(t.slice(1,4),10);const n=e.algorithm.length;if(n!==r)throw unusable(r,"algorithm.length");break}case"ECDH":switch(e.algorithm.name){case"ECDH":case"X25519":case"X448":break;default:throw unusable("ECDH, X25519, or X448")}break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":if(!isAlgorithm(e.algorithm,"PBKDF2"))throw unusable("PBKDF2");break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":{if(!isAlgorithm(e.algorithm,"RSA-OAEP"))throw unusable("RSA-OAEP");const r=parseInt(t.slice(9),10)||1;const n=getHashLength(e.algorithm.hash);if(n!==r)throw unusable(`SHA-${r}`,"algorithm.hash");break}default:throw new TypeError("CryptoKey does not support this operation")}checkUsage(e,r)}function message(e,t,...r){if(r.length>2){const t=r.pop();e+=`one of type ${r.join(", ")}, or ${t}.`}else 2===r.length?e+=`one of type ${r[0]} or ${r[1]}.`:e+=`of type ${r[0]}.`;null==t?e+=` Received ${t}`:"function"===typeof t&&t.name?e+=` Received function ${t.name}`:"object"===typeof t&&null!=t&&t.constructor&&t.constructor.name&&(e+=` Received an instance of ${t.constructor.name}`);return e}var invalidKeyInput=(e,...t)=>message("Key must be ",e,...t);function withAlg(e,t,...r){return message(`Key for the ${e} algorithm must be `,t,...r)}var isKeyLike=e=>isCryptoKey(e);const o=["CryptoKey"];async function cbcDecrypt(t,r,n,a,i,o){if(!(r instanceof Uint8Array))throw new TypeError(invalidKeyInput(r,"Uint8Array"));const s=parseInt(t.slice(1,4),10);const c=await e.subtle.importKey("raw",r.subarray(s>>3),"AES-CBC",false,["decrypt"]);const d=await e.subtle.importKey("raw",r.subarray(0,s>>3),{hash:"SHA-"+(s<<1),name:"HMAC"},false,["sign"]);const l=concat(o,a,n,uint64be(o.length<<3));const p=new Uint8Array((await e.subtle.sign("HMAC",d,l)).slice(0,s>>3));let u;try{u=timingSafeEqual(i,p)}catch(e){}if(!u)throw new JWEDecryptionFailed;let h;try{h=new Uint8Array(await e.subtle.decrypt({iv:a,name:"AES-CBC"},c,n))}catch(e){}if(!h)throw new JWEDecryptionFailed;return h}async function gcmDecrypt(t,r,n,a,i,o){let s;if(r instanceof Uint8Array)s=await e.subtle.importKey("raw",r,"AES-GCM",false,["decrypt"]);else{checkEncCryptoKey(r,t,"decrypt");s=r}try{return new Uint8Array(await e.subtle.decrypt({additionalData:o,iv:a,name:"AES-GCM",tagLength:128},s,concat(n,i)))}catch(e){throw new JWEDecryptionFailed}}const decrypt$2=async(e,t,r,n,a,i)=>{if(!isCryptoKey(t)&&!(t instanceof Uint8Array))throw new TypeError(invalidKeyInput(t,...o,"Uint8Array"));checkIvLength(e,n);switch(e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":t instanceof Uint8Array&&checkCekLength(t,parseInt(e.slice(-3),10));return cbcDecrypt(e,t,r,n,a,i);case"A128GCM":case"A192GCM":case"A256GCM":t instanceof Uint8Array&&checkCekLength(t,parseInt(e.slice(1,4),10));return gcmDecrypt(e,t,r,n,a,i);default:throw new JOSENotSupported("Unsupported JWE Content Encryption Algorithm")}};const inflate=async()=>{throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `inflateRaw` decrypt option to provide Inflate Raw implementation.')};const deflate=async()=>{throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `deflateRaw` encrypt option to provide Deflate Raw implementation.')};const isDisjoint=(...e)=>{const t=e.filter(Boolean);if(0===t.length||1===t.length)return true;let r;for(const e of t){const t=Object.keys(e);if(r&&0!==r.size)for(const e of t){if(r.has(e))return false;r.add(e)}else r=new Set(t)}return true};function isObjectLike(e){return"object"===typeof e&&null!==e}function isObject(e){if(!isObjectLike(e)||"[object Object]"!==Object.prototype.toString.call(e))return false;if(null===Object.getPrototypeOf(e))return true;let t=e;while(null!==Object.getPrototypeOf(t))t=Object.getPrototypeOf(t);return Object.getPrototypeOf(e)===t}const s=[{hash:"SHA-256",name:"HMAC"},true,["sign"]];function checkKeySize(e,t){if(e.algorithm.length!==parseInt(t.slice(1,4),10))throw new TypeError(`Invalid key size for alg: ${t}`)}function getCryptoKey$2(t,r,n){if(isCryptoKey(t)){checkEncCryptoKey(t,r,n);return t}if(t instanceof Uint8Array)return e.subtle.importKey("raw",t,"AES-KW",true,[n]);throw new TypeError(invalidKeyInput(t,...o,"Uint8Array"))}const wrap$1=async(t,r,n)=>{const a=await getCryptoKey$2(r,t,"wrapKey");checkKeySize(a,t);const i=await e.subtle.importKey("raw",n,...s);return new Uint8Array(await e.subtle.wrapKey("raw",i,a,"AES-KW"))};const unwrap$1=async(t,r,n)=>{const a=await getCryptoKey$2(r,t,"unwrapKey");checkKeySize(a,t);const i=await e.subtle.unwrapKey("raw",n,a,"AES-KW",...s);return new Uint8Array(await e.subtle.exportKey("raw",i))};async function deriveKey$1(r,n,a,i,s=new Uint8Array(0),c=new Uint8Array(0)){if(!isCryptoKey(r))throw new TypeError(invalidKeyInput(r,...o));checkEncCryptoKey(r,"ECDH");if(!isCryptoKey(n))throw new TypeError(invalidKeyInput(n,...o));checkEncCryptoKey(n,"ECDH","deriveBits");const d=concat(lengthAndInput(t.encode(a)),lengthAndInput(s),lengthAndInput(c),uint32be(i));let l;l="X25519"===r.algorithm.name?256:"X448"===r.algorithm.name?448:Math.ceil(parseInt(r.algorithm.namedCurve.substr(-3),10)/8)<<3;const p=new Uint8Array(await e.subtle.deriveBits({name:r.algorithm.name,public:r},n,l));return concatKdf(p,i,d)}async function generateEpk(t){if(!isCryptoKey(t))throw new TypeError(invalidKeyInput(t,...o));return e.subtle.generateKey(t.algorithm,true,["deriveBits"])}function ecdhAllowed(e){if(!isCryptoKey(e))throw new TypeError(invalidKeyInput(e,...o));return["P-256","P-384","P-521"].includes(e.algorithm.namedCurve)||"X25519"===e.algorithm.name||"X448"===e.algorithm.name}function checkP2s(e){if(!(e instanceof Uint8Array)||e.length<8)throw new JWEInvalid("PBES2 Salt Input must be 8 or more octets")}function getCryptoKey$1(t,r){if(t instanceof Uint8Array)return e.subtle.importKey("raw",t,"PBKDF2",false,["deriveBits"]);if(isCryptoKey(t)){checkEncCryptoKey(t,r,"deriveBits","deriveKey");return t}throw new TypeError(invalidKeyInput(t,...o,"Uint8Array"))}async function deriveKey(t,r,n,a){checkP2s(t);const i=p2s(r,t);const o=parseInt(r.slice(13,16),10);const s={hash:`SHA-${r.slice(8,11)}`,iterations:n,name:"PBKDF2",salt:i};const c={length:o,name:"AES-KW"};const d=await getCryptoKey$1(a,r);if(d.usages.includes("deriveBits"))return new Uint8Array(await e.subtle.deriveBits(s,d,o));if(d.usages.includes("deriveKey"))return e.subtle.deriveKey(s,d,c,false,["wrapKey","unwrapKey"]);throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"')}const encrypt$2=async(e,t,r,n=2048,a=i(new Uint8Array(16)))=>{const o=await deriveKey(a,e,n,t);const s=await wrap$1(e.slice(-6),o,r);return{encryptedKey:s,p2c:n,p2s:encode$1(a)}};const decrypt$1=async(e,t,r,n,a)=>{const i=await deriveKey(a,e,n,t);return unwrap$1(e.slice(-6),i,r)};function subtleRsaEs(e){switch(e){case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":return"RSA-OAEP";default:throw new JOSENotSupported(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}var checkKeyLength=(e,t)=>{if(e.startsWith("RS")||e.startsWith("PS")){const{modulusLength:r}=t.algorithm;if("number"!==typeof r||r<2048)throw new TypeError(`${e} requires key modulusLength to be 2048 bits or larger`)}};const encrypt$1=async(t,r,n)=>{if(!isCryptoKey(r))throw new TypeError(invalidKeyInput(r,...o));checkEncCryptoKey(r,t,"encrypt","wrapKey");checkKeyLength(t,r);if(r.usages.includes("encrypt"))return new Uint8Array(await e.subtle.encrypt(subtleRsaEs(t),r,n));if(r.usages.includes("wrapKey")){const a=await e.subtle.importKey("raw",n,...s);return new Uint8Array(await e.subtle.wrapKey("raw",a,r,subtleRsaEs(t)))}throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation')};const decrypt=async(t,r,n)=>{if(!isCryptoKey(r))throw new TypeError(invalidKeyInput(r,...o));checkEncCryptoKey(r,t,"decrypt","unwrapKey");checkKeyLength(t,r);if(r.usages.includes("decrypt"))return new Uint8Array(await e.subtle.decrypt(subtleRsaEs(t),r,n));if(r.usages.includes("unwrapKey")){const a=await e.subtle.unwrapKey("raw",n,r,subtleRsaEs(t),...s);return new Uint8Array(await e.subtle.exportKey("raw",a))}throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation')};function bitLength(e){switch(e){case"A128GCM":return 128;case"A192GCM":return 192;case"A256GCM":case"A128CBC-HS256":return 256;case"A192CBC-HS384":return 384;case"A256CBC-HS512":return 512;default:throw new JOSENotSupported(`Unsupported JWE Algorithm: ${e}`)}}var generateCek=e=>i(new Uint8Array(bitLength(e)>>3));var formatPEM=(e,t)=>{const r=(e.match(/.{1,64}/g)||[]).join("\n");return`-----BEGIN ${t}-----\n${r}\n-----END ${t}-----`};const genericExport=async(t,r,n)=>{if(!isCryptoKey(n))throw new TypeError(invalidKeyInput(n,...o));if(!n.extractable)throw new TypeError("CryptoKey is not extractable");if(n.type!==t)throw new TypeError(`key is not a ${t} key`);return formatPEM(encodeBase64(new Uint8Array(await e.subtle.exportKey(r,n))),`${t.toUpperCase()} KEY`)};const toSPKI=e=>genericExport("public","spki",e);const toPKCS8=e=>genericExport("private","pkcs8",e);const findOid=(e,t,r=0)=>{if(0===r){t.unshift(t.length);t.unshift(6)}let n=e.indexOf(t[0],r);if(-1===n)return false;const a=e.subarray(n,n+t.length);return a.length===t.length&&(a.every(((e,r)=>e===t[r]))||findOid(e,t,n+1))};const getNamedCurve=e=>{switch(true){case findOid(e,[42,134,72,206,61,3,1,7]):return"P-256";case findOid(e,[43,129,4,0,34]):return"P-384";case findOid(e,[43,129,4,0,35]):return"P-521";case findOid(e,[43,101,110]):return"X25519";case findOid(e,[43,101,111]):return"X448";case findOid(e,[43,101,112]):return"Ed25519";case findOid(e,[43,101,113]):return"Ed448";default:throw new JOSENotSupported("Invalid or unsupported EC Key Curve or OKP Key Sub Type")}};const genericImport=async(t,r,n,a,i)=>{var o;let s;let c;const d=new Uint8Array(atob(n.replace(t,"")).split("").map((e=>e.charCodeAt(0))));const l="spki"===r;switch(a){case"PS256":case"PS384":case"PS512":s={name:"RSA-PSS",hash:`SHA-${a.slice(-3)}`};c=l?["verify"]:["sign"];break;case"RS256":case"RS384":case"RS512":s={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${a.slice(-3)}`};c=l?["verify"]:["sign"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":s={name:"RSA-OAEP",hash:`SHA-${parseInt(a.slice(-3),10)||1}`};c=l?["encrypt","wrapKey"]:["decrypt","unwrapKey"];break;case"ES256":s={name:"ECDSA",namedCurve:"P-256"};c=l?["verify"]:["sign"];break;case"ES384":s={name:"ECDSA",namedCurve:"P-384"};c=l?["verify"]:["sign"];break;case"ES512":s={name:"ECDSA",namedCurve:"P-521"};c=l?["verify"]:["sign"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{const e=getNamedCurve(d);s=e.startsWith("P-")?{name:"ECDH",namedCurve:e}:{name:e};c=l?[]:["deriveBits"];break}case isCloudflareWorkers()&&"EdDSA":{const e=getNamedCurve(d).toUpperCase();s={name:`NODE-${e}`,namedCurve:`NODE-${e}`};c=l?["verify"]:["sign"];break}case"EdDSA":s={name:getNamedCurve(d)};c=l?["verify"]:["sign"];break;default:throw new JOSENotSupported('Invalid or unsupported "alg" (Algorithm) value')}return e.subtle.importKey(r,d,s,null!==(o=null===i||void 0===i?void 0:i.extractable)&&void 0!==o&&o,c)};const fromPKCS8=(e,t,r)=>genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g,"pkcs8",e,t,r);const fromSPKI=(e,t,r)=>genericImport(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g,"spki",e,t,r);function subtleMapping(e){let t;let r;switch(e.kty){case"oct":switch(e.alg){case"HS256":case"HS384":case"HS512":t={name:"HMAC",hash:`SHA-${e.alg.slice(-3)}`};r=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":throw new JOSENotSupported(`${e.alg} keys cannot be imported as CryptoKey instances`);case"A128GCM":case"A192GCM":case"A256GCM":case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":t={name:"AES-GCM"};r=["encrypt","decrypt"];break;case"A128KW":case"A192KW":case"A256KW":t={name:"AES-KW"};r=["wrapKey","unwrapKey"];break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":t={name:"PBKDF2"};r=["deriveBits"];break;default:throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"RSA":switch(e.alg){case"PS256":case"PS384":case"PS512":t={name:"RSA-PSS",hash:`SHA-${e.alg.slice(-3)}`};r=e.d?["sign"]:["verify"];break;case"RS256":case"RS384":case"RS512":t={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${e.alg.slice(-3)}`};r=e.d?["sign"]:["verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":t={name:"RSA-OAEP",hash:`SHA-${parseInt(e.alg.slice(-3),10)||1}`};r=e.d?["decrypt","unwrapKey"]:["encrypt","wrapKey"];break;default:throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"EC":switch(e.alg){case"ES256":t={name:"ECDSA",namedCurve:"P-256"};r=e.d?["sign"]:["verify"];break;case"ES384":t={name:"ECDSA",namedCurve:"P-384"};r=e.d?["sign"]:["verify"];break;case"ES512":t={name:"ECDSA",namedCurve:"P-521"};r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:"ECDH",namedCurve:e.crv};r=e.d?["deriveBits"]:[];break;default:throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case isCloudflareWorkers()&&"OKP":if("EdDSA"!==e.alg)throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');switch(e.crv){case"Ed25519":t={name:"NODE-ED25519",namedCurve:"NODE-ED25519"};r=e.d?["sign"]:["verify"];break;default:throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;case"OKP":switch(e.alg){case"EdDSA":t={name:e.crv};r=e.d?["sign"]:["verify"];break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":t={name:e.crv};r=e.d?["deriveBits"]:[];break;default:throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}break;default:throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value')}return{algorithm:t,keyUsages:r}}const parse=async t=>{var r,n;const{algorithm:a,keyUsages:i}=subtleMapping(t);const o=[a,null!==(r=t.ext)&&void 0!==r&&r,null!==(n=t.key_ops)&&void 0!==n?n:i];if("PBKDF2"===a.name)return e.subtle.importKey("raw",decode$1(t.k),...o);const s={...t};delete s.alg;delete s.use;return e.subtle.importKey("jwk",s,...o)};function getElement(e){let t=[];let r=0;while(r<e.length){let n=parseElement(e.subarray(r));t.push(n);r+=n.byteLength}return t}function parseElement(e){let t=0;let r=31&e[0];t++;if(31===r){r=0;while(e[t]>=128){r=128*r+e[t]-128;t++}r=128*r+e[t]-128;t++}let n=0;if(e[t]<128){n=e[t];t++}else{if(128===n){n=0;while(0!==e[t+n]||0!==e[t+n+1]){if(n>e.byteLength)throw new TypeError("invalid indefinite form length");n++}const r=t+n+2;return{byteLength:r,contents:e.subarray(t,t+n),raw:e.subarray(0,r)}}{let r=127&e[t];t++;n=0;for(let a=0;a<r;a++){n=256*n+e[t];t++}}}const a=t+n;return{byteLength:a,contents:e.subarray(t,a),raw:e.subarray(0,a)}}function spkiFromX509(e){const t=getElement(getElement(parseElement(e).contents)[0].contents);return encodeBase64(t[160===t[0].raw[0]?6:5].raw)}function getSPKI(e){const t=e.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g,"");const r=decodeBase64(t);return formatPEM(spkiFromX509(r),"PUBLIC KEY")}async function importSPKI(e,t,r){if("string"!==typeof e||0!==e.indexOf("-----BEGIN PUBLIC KEY-----"))throw new TypeError('"spki" must be SPKI formatted string');return fromSPKI(e,t,r)}async function importX509(e,t,r){if("string"!==typeof e||0!==e.indexOf("-----BEGIN CERTIFICATE-----"))throw new TypeError('"x509" must be X.509 formatted string');let n;try{n=getSPKI(e)}catch(e){throw new TypeError("failed to parse the X.509 certificate",{cause:e})}return fromSPKI(n,t,r)}async function importPKCS8(e,t,r){if("string"!==typeof e||0!==e.indexOf("-----BEGIN PRIVATE KEY-----"))throw new TypeError('"pkcs8" must be PKCS#8 formatted string');return fromPKCS8(e,t,r)}async function importJWK(e,t,r){var n;if(!isObject(e))throw new TypeError("JWK must be an object");t||(t=e.alg);if("string"!==typeof t||!t)throw new TypeError('"alg" argument is required when "jwk.alg" is not present');switch(e.kty){case"oct":if("string"!==typeof e.k||!e.k)throw new TypeError('missing "k" (Key Value) Parameter value');null!==r&&void 0!==r?r:r=true!==e.ext;return r?parse({...e,alg:t,ext:null!==(n=e.ext)&&void 0!==n&&n}):decode$1(e.k);case"RSA":if(void 0!==e.oth)throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');case"EC":case"OKP":return parse({...e,alg:t});default:throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value')}}const symmetricTypeCheck=(e,t)=>{if(!(t instanceof Uint8Array)){if(!isKeyLike(t))throw new TypeError(withAlg(e,t,...o,"Uint8Array"));if("secret"!==t.type)throw new TypeError(`${o.join(" or ")} instances for symmetric algorithms must be of type "secret"`)}};const asymmetricTypeCheck=(e,t,r)=>{if(!isKeyLike(t))throw new TypeError(withAlg(e,t,...o));if("secret"===t.type)throw new TypeError(`${o.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);if("sign"===r&&"public"===t.type)throw new TypeError(`${o.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);if("decrypt"===r&&"public"===t.type)throw new TypeError(`${o.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);if(t.algorithm&&"verify"===r&&"private"===t.type)throw new TypeError(`${o.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);if(t.algorithm&&"encrypt"===r&&"private"===t.type)throw new TypeError(`${o.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`)};const checkKeyType=(e,t,r)=>{const n=e.startsWith("HS")||"dir"===e||e.startsWith("PBES2")||/^A\d{3}(?:GCM)?KW$/.test(e);n?symmetricTypeCheck(e,t):asymmetricTypeCheck(e,t,r)};async function cbcEncrypt(t,r,n,a,i){if(!(n instanceof Uint8Array))throw new TypeError(invalidKeyInput(n,"Uint8Array"));const o=parseInt(t.slice(1,4),10);const s=await e.subtle.importKey("raw",n.subarray(o>>3),"AES-CBC",false,["encrypt"]);const c=await e.subtle.importKey("raw",n.subarray(0,o>>3),{hash:"SHA-"+(o<<1),name:"HMAC"},false,["sign"]);const d=new Uint8Array(await e.subtle.encrypt({iv:a,name:"AES-CBC"},s,r));const l=concat(i,a,d,uint64be(i.length<<3));const p=new Uint8Array((await e.subtle.sign("HMAC",c,l)).slice(0,o>>3));return{ciphertext:d,tag:p}}async function gcmEncrypt(t,r,n,a,i){let o;if(n instanceof Uint8Array)o=await e.subtle.importKey("raw",n,"AES-GCM",false,["encrypt"]);else{checkEncCryptoKey(n,t,"encrypt");o=n}const s=new Uint8Array(await e.subtle.encrypt({additionalData:i,iv:a,name:"AES-GCM",tagLength:128},o,r));const c=s.slice(-16);const d=s.slice(0,-16);return{ciphertext:d,tag:c}}const encrypt=async(e,t,r,n,a)=>{if(!isCryptoKey(r)&&!(r instanceof Uint8Array))throw new TypeError(invalidKeyInput(r,...o,"Uint8Array"));checkIvLength(e,n);switch(e){case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":r instanceof Uint8Array&&checkCekLength(r,parseInt(e.slice(-3),10));return cbcEncrypt(e,t,r,n,a);case"A128GCM":case"A192GCM":case"A256GCM":r instanceof Uint8Array&&checkCekLength(r,parseInt(e.slice(1,4),10));return gcmEncrypt(e,t,r,n,a);default:throw new JOSENotSupported("Unsupported JWE Content Encryption Algorithm")}};async function wrap(e,t,r,n){const a=e.slice(0,7);n||(n=generateIv(a));const{ciphertext:i,tag:o}=await encrypt(a,r,t,n,new Uint8Array(0));return{encryptedKey:i,iv:encode$1(n),tag:encode$1(o)}}async function unwrap(e,t,r,n,a){const i=e.slice(0,7);return decrypt$2(i,t,r,n,a,new Uint8Array(0))}async function decryptKeyManagement(e,t,r,n,a){checkKeyType(e,t,"decrypt");switch(e){case"dir":if(void 0!==r)throw new JWEInvalid("Encountered unexpected JWE Encrypted Key");return t;case"ECDH-ES":if(void 0!==r)throw new JWEInvalid("Encountered unexpected JWE Encrypted Key");case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!isObject(n.epk))throw new JWEInvalid('JOSE Header "epk" (Ephemeral Public Key) missing or invalid');if(!ecdhAllowed(t))throw new JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");const a=await importJWK(n.epk,e);let i;let o;if(void 0!==n.apu){if("string"!==typeof n.apu)throw new JWEInvalid('JOSE Header "apu" (Agreement PartyUInfo) invalid');i=decode$1(n.apu)}if(void 0!==n.apv){if("string"!==typeof n.apv)throw new JWEInvalid('JOSE Header "apv" (Agreement PartyVInfo) invalid');o=decode$1(n.apv)}const s=await deriveKey$1(a,t,"ECDH-ES"===e?n.enc:e,"ECDH-ES"===e?bitLength(n.enc):parseInt(e.slice(-5,-2),10),i,o);if("ECDH-ES"===e)return s;if(void 0===r)throw new JWEInvalid("JWE Encrypted Key missing");return unwrap$1(e.slice(-6),s,r)}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":if(void 0===r)throw new JWEInvalid("JWE Encrypted Key missing");return decrypt(e,t,r);case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{if(void 0===r)throw new JWEInvalid("JWE Encrypted Key missing");if("number"!==typeof n.p2c)throw new JWEInvalid('JOSE Header "p2c" (PBES2 Count) missing or invalid');const i=(null===a||void 0===a?void 0:a.maxPBES2Count)||1e4;if(n.p2c>i)throw new JWEInvalid('JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds');if("string"!==typeof n.p2s)throw new JWEInvalid('JOSE Header "p2s" (PBES2 Salt) missing or invalid');return decrypt$1(e,t,r,n.p2c,decode$1(n.p2s))}case"A128KW":case"A192KW":case"A256KW":if(void 0===r)throw new JWEInvalid("JWE Encrypted Key missing");return unwrap$1(e,t,r);case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{if(void 0===r)throw new JWEInvalid("JWE Encrypted Key missing");if("string"!==typeof n.iv)throw new JWEInvalid('JOSE Header "iv" (Initialization Vector) missing or invalid');if("string"!==typeof n.tag)throw new JWEInvalid('JOSE Header "tag" (Authentication Tag) missing or invalid');const a=decode$1(n.iv);const i=decode$1(n.tag);return unwrap(e,t,r,a,i)}default:throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value')}}function validateCrit(e,t,r,n,a){if(void 0!==a.crit&&void 0===n.crit)throw new e('"crit" (Critical) Header Parameter MUST be integrity protected');if(!n||void 0===n.crit)return new Set;if(!Array.isArray(n.crit)||0===n.crit.length||n.crit.some((e=>"string"!==typeof e||0===e.length)))throw new e('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');let i;i=void 0!==r?new Map([...Object.entries(r),...t.entries()]):t;for(const t of n.crit){if(!i.has(t))throw new JOSENotSupported(`Extension Header Parameter "${t}" is not recognized`);if(void 0===a[t])throw new e(`Extension Header Parameter "${t}" is missing`);if(i.get(t)&&void 0===n[t])throw new e(`Extension Header Parameter "${t}" MUST be integrity protected`)}return new Set(n.crit)}const validateAlgorithms=(e,t)=>{if(void 0!==t&&(!Array.isArray(t)||t.some((e=>"string"!==typeof e))))throw new TypeError(`"${e}" option must be an array of strings`);if(t)return new Set(t)};async function flattenedDecrypt(e,n,a){var i;if(!isObject(e))throw new JWEInvalid("Flattened JWE must be an object");if(void 0===e.protected&&void 0===e.header&&void 0===e.unprotected)throw new JWEInvalid("JOSE Header missing");if("string"!==typeof e.iv)throw new JWEInvalid("JWE Initialization Vector missing or incorrect type");if("string"!==typeof e.ciphertext)throw new JWEInvalid("JWE Ciphertext missing or incorrect type");if("string"!==typeof e.tag)throw new JWEInvalid("JWE Authentication Tag missing or incorrect type");if(void 0!==e.protected&&"string"!==typeof e.protected)throw new JWEInvalid("JWE Protected Header incorrect type");if(void 0!==e.encrypted_key&&"string"!==typeof e.encrypted_key)throw new JWEInvalid("JWE Encrypted Key incorrect type");if(void 0!==e.aad&&"string"!==typeof e.aad)throw new JWEInvalid("JWE AAD incorrect type");if(void 0!==e.header&&!isObject(e.header))throw new JWEInvalid("JWE Shared Unprotected Header incorrect type");if(void 0!==e.unprotected&&!isObject(e.unprotected))throw new JWEInvalid("JWE Per-Recipient Unprotected Header incorrect type");let o;if(e.protected)try{const t=decode$1(e.protected);o=JSON.parse(r.decode(t))}catch(e){throw new JWEInvalid("JWE Protected Header is invalid")}if(!isDisjoint(o,e.header,e.unprotected))throw new JWEInvalid("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");const s={...o,...e.header,...e.unprotected};validateCrit(JWEInvalid,new Map,null===a||void 0===a?void 0:a.crit,o,s);if(void 0!==s.zip){if(!o||!o.zip)throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');if("DEF"!==s.zip)throw new JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value')}const{alg:c,enc:d}=s;if("string"!==typeof c||!c)throw new JWEInvalid("missing JWE Algorithm (alg) in JWE Header");if("string"!==typeof d||!d)throw new JWEInvalid("missing JWE Encryption Algorithm (enc) in JWE Header");const l=a&&validateAlgorithms("keyManagementAlgorithms",a.keyManagementAlgorithms);const p=a&&validateAlgorithms("contentEncryptionAlgorithms",a.contentEncryptionAlgorithms);if(l&&!l.has(c))throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');if(p&&!p.has(d))throw new JOSEAlgNotAllowed('"enc" (Encryption Algorithm) Header Parameter not allowed');let u;void 0!==e.encrypted_key&&(u=decode$1(e.encrypted_key));let h=false;if("function"===typeof n){n=await n(o,e);h=true}let y;try{y=await decryptKeyManagement(c,n,u,s,a)}catch(e){if(e instanceof TypeError||e instanceof JWEInvalid||e instanceof JOSENotSupported)throw e;y=generateCek(d)}const w=decode$1(e.iv);const f=decode$1(e.tag);const E=t.encode(null!==(i=e.protected)&&void 0!==i?i:"");let g;g=void 0!==e.aad?concat(E,t.encode("."),t.encode(e.aad)):E;let m=await decrypt$2(d,y,decode$1(e.ciphertext),w,f,g);"DEF"===s.zip&&(m=await((null===a||void 0===a?void 0:a.inflateRaw)||inflate)(m));const S={plaintext:m};void 0!==e.protected&&(S.protectedHeader=o);void 0!==e.aad&&(S.additionalAuthenticatedData=decode$1(e.aad));void 0!==e.unprotected&&(S.sharedUnprotectedHeader=e.unprotected);void 0!==e.header&&(S.unprotectedHeader=e.header);return h?{...S,key:n}:S}async function compactDecrypt(e,t,n){e instanceof Uint8Array&&(e=r.decode(e));if("string"!==typeof e)throw new JWEInvalid("Compact JWE must be a string or Uint8Array");const{0:a,1:i,2:o,3:s,4:c,length:d}=e.split(".");if(5!==d)throw new JWEInvalid("Invalid Compact JWE");const l=await flattenedDecrypt({ciphertext:s,iv:o||void 0,protected:a||void 0,tag:c||void 0,encrypted_key:i||void 0},t,n);const p={plaintext:l.plaintext,protectedHeader:l.protectedHeader};return"function"===typeof t?{...p,key:l.key}:p}async function generalDecrypt(e,t,r){if(!isObject(e))throw new JWEInvalid("General JWE must be an object");if(!Array.isArray(e.recipients)||!e.recipients.every(isObject))throw new JWEInvalid("JWE Recipients missing or incorrect type");if(!e.recipients.length)throw new JWEInvalid("JWE Recipients has no members");for(const n of e.recipients)try{return await flattenedDecrypt({aad:e.aad,ciphertext:e.ciphertext,encrypted_key:n.encrypted_key,header:n.header,iv:e.iv,protected:e.protected,tag:e.tag,unprotected:e.unprotected},t,r)}catch(e){}throw new JWEDecryptionFailed}const keyToJWK=async t=>{if(t instanceof Uint8Array)return{kty:"oct",k:encode$1(t)};if(!isCryptoKey(t))throw new TypeError(invalidKeyInput(t,...o,"Uint8Array"));if(!t.extractable)throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");const{ext:r,key_ops:n,alg:a,use:i,...s}=await e.subtle.exportKey("jwk",t);return s};async function exportSPKI(e){return toSPKI(e)}async function exportPKCS8(e){return toPKCS8(e)}async function exportJWK(e){return keyToJWK(e)}async function encryptKeyManagement(e,t,r,n,a={}){let i;let o;let s;checkKeyType(e,r,"encrypt");switch(e){case"dir":s=r;break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{if(!ecdhAllowed(r))throw new JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");const{apu:c,apv:d}=a;let{epk:l}=a;l||(l=(await generateEpk(r)).privateKey);const{x:p,y:u,crv:h,kty:y}=await exportJWK(l);const w=await deriveKey$1(r,l,"ECDH-ES"===e?t:e,"ECDH-ES"===e?bitLength(t):parseInt(e.slice(-5,-2),10),c,d);o={epk:{x:p,crv:h,kty:y}};"EC"===y&&(o.epk.y=u);c&&(o.apu=encode$1(c));d&&(o.apv=encode$1(d));if("ECDH-ES"===e){s=w;break}s=n||generateCek(t);const f=e.slice(-6);i=await wrap$1(f,w,s);break}case"RSA1_5":case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":s=n||generateCek(t);i=await encrypt$1(e,r,s);break;case"PBES2-HS256+A128KW":case"PBES2-HS384+A192KW":case"PBES2-HS512+A256KW":{s=n||generateCek(t);const{p2c:c,p2s:d}=a;({encryptedKey:i,...o}=await encrypt$2(e,r,s,c,d));break}case"A128KW":case"A192KW":case"A256KW":s=n||generateCek(t);i=await wrap$1(e,r,s);break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":{s=n||generateCek(t);const{iv:c}=a;({encryptedKey:i,...o}=await wrap(e,r,s,c));break}default:throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value')}return{cek:s,encryptedKey:i,parameters:o}}const c=Symbol();class FlattenedEncrypt{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("plaintext must be an instance of Uint8Array");this._plaintext=e}setKeyManagementParameters(e){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");this._keyManagementParameters=e;return this}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");this._protectedHeader=e;return this}setSharedUnprotectedHeader(e){if(this._sharedUnprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");this._sharedUnprotectedHeader=e;return this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");this._unprotectedHeader=e;return this}setAdditionalAuthenticatedData(e){this._aad=e;return this}setContentEncryptionKey(e){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");this._cek=e;return this}setInitializationVector(e){if(this._iv)throw new TypeError("setInitializationVector can only be called once");this._iv=e;return this}async encrypt(e,n){if(!this._protectedHeader&&!this._unprotectedHeader&&!this._sharedUnprotectedHeader)throw new JWEInvalid("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");if(!isDisjoint(this._protectedHeader,this._unprotectedHeader,this._sharedUnprotectedHeader))throw new JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const a={...this._protectedHeader,...this._unprotectedHeader,...this._sharedUnprotectedHeader};validateCrit(JWEInvalid,new Map,null===n||void 0===n?void 0:n.crit,this._protectedHeader,a);if(void 0!==a.zip){if(!this._protectedHeader||!this._protectedHeader.zip)throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');if("DEF"!==a.zip)throw new JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value')}const{alg:i,enc:o}=a;if("string"!==typeof i||!i)throw new JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("string"!==typeof o||!o)throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');let s;if("dir"===i){if(this._cek)throw new TypeError("setContentEncryptionKey cannot be called when using Direct Encryption")}else if("ECDH-ES"===i&&this._cek)throw new TypeError("setContentEncryptionKey cannot be called when using Direct Key Agreement");let d;{let t;({cek:d,encryptedKey:s,parameters:t}=await encryptKeyManagement(i,o,e,this._cek,this._keyManagementParameters));t&&(n&&c in n?this._unprotectedHeader?this._unprotectedHeader={...this._unprotectedHeader,...t}:this.setUnprotectedHeader(t):this._protectedHeader?this._protectedHeader={...this._protectedHeader,...t}:this.setProtectedHeader(t))}this._iv||(this._iv=generateIv(o));let l;let p;let u;p=this._protectedHeader?t.encode(encode$1(JSON.stringify(this._protectedHeader))):t.encode("");if(this._aad){u=encode$1(this._aad);l=concat(p,t.encode("."),t.encode(u))}else l=p;let h;let y;if("DEF"===a.zip){const e=await((null===n||void 0===n?void 0:n.deflateRaw)||deflate)(this._plaintext);({ciphertext:h,tag:y}=await encrypt(o,e,d,this._iv,l))}else({ciphertext:h,tag:y}=await encrypt(o,this._plaintext,d,this._iv,l));const w={ciphertext:encode$1(h),iv:encode$1(this._iv),tag:encode$1(y)};s&&(w.encrypted_key=encode$1(s));u&&(w.aad=u);this._protectedHeader&&(w.protected=r.decode(p));this._sharedUnprotectedHeader&&(w.unprotected=this._sharedUnprotectedHeader);this._unprotectedHeader&&(w.header=this._unprotectedHeader);return w}}class IndividualRecipient{constructor(e,t,r){this.parent=e;this.key=t;this.options=r}setUnprotectedHeader(e){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");this.unprotectedHeader=e;return this}addRecipient(...e){return this.parent.addRecipient(...e)}encrypt(...e){return this.parent.encrypt(...e)}done(){return this.parent}}class GeneralEncrypt{constructor(e){this._recipients=[];this._plaintext=e}addRecipient(e,t){const r=new IndividualRecipient(this,e,{crit:null===t||void 0===t?void 0:t.crit});this._recipients.push(r);return r}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");this._protectedHeader=e;return this}setSharedUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setSharedUnprotectedHeader can only be called once");this._unprotectedHeader=e;return this}setAdditionalAuthenticatedData(e){this._aad=e;return this}async encrypt(e){var t,r,n;if(!this._recipients.length)throw new JWEInvalid("at least one recipient must be added");e={deflateRaw:null===e||void 0===e?void 0:e.deflateRaw};if(1===this._recipients.length){const[t]=this._recipients;const r=await new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(t.unprotectedHeader).encrypt(t.key,{...t.options,...e});let n={ciphertext:r.ciphertext,iv:r.iv,recipients:[{}],tag:r.tag};r.aad&&(n.aad=r.aad);r.protected&&(n.protected=r.protected);r.unprotected&&(n.unprotected=r.unprotected);r.encrypted_key&&(n.recipients[0].encrypted_key=r.encrypted_key);r.header&&(n.recipients[0].header=r.header);return n}let a;for(let e=0;e<this._recipients.length;e++){const t=this._recipients[e];if(!isDisjoint(this._protectedHeader,this._unprotectedHeader,t.unprotectedHeader))throw new JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");const r={...this._protectedHeader,...this._unprotectedHeader,...t.unprotectedHeader};const{alg:n}=r;if("string"!==typeof n||!n)throw new JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');if("dir"===n||"ECDH-ES"===n)throw new JWEInvalid('"dir" and "ECDH-ES" alg may only be used with a single recipient');if("string"!==typeof r.enc||!r.enc)throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');if(a){if(a!==r.enc)throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients')}else a=r.enc;validateCrit(JWEInvalid,new Map,t.options.crit,this._protectedHeader,r);if(void 0!==r.zip&&(!this._protectedHeader||!this._protectedHeader.zip))throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected')}const i=generateCek(a);let o={ciphertext:"",iv:"",recipients:[],tag:""};for(let s=0;s<this._recipients.length;s++){const d=this._recipients[s];const l={};o.recipients.push(l);const p={...this._protectedHeader,...this._unprotectedHeader,...d.unprotectedHeader};const u=p.alg.startsWith("PBES2")?2048+s:void 0;if(0===s){const t=await new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(i).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(d.unprotectedHeader).setKeyManagementParameters({p2c:u}).encrypt(d.key,{...d.options,...e,[c]:true});o.ciphertext=t.ciphertext;o.iv=t.iv;o.tag=t.tag;t.aad&&(o.aad=t.aad);t.protected&&(o.protected=t.protected);t.unprotected&&(o.unprotected=t.unprotected);l.encrypted_key=t.encrypted_key;t.header&&(l.header=t.header);continue}const{encryptedKey:h,parameters:y}=await encryptKeyManagement((null===(t=d.unprotectedHeader)||void 0===t?void 0:t.alg)||(null===(r=this._protectedHeader)||void 0===r?void 0:r.alg)||(null===(n=this._unprotectedHeader)||void 0===n?void 0:n.alg),a,d.key,i,{p2c:u});l.encrypted_key=encode$1(h);(d.unprotectedHeader||y)&&(l.header={...d.unprotectedHeader,...y})}return o}}function subtleDsa(e,t){const r=`SHA-${e.slice(-3)}`;switch(e){case"HS256":case"HS384":case"HS512":return{hash:r,name:"HMAC"};case"PS256":case"PS384":case"PS512":return{hash:r,name:"RSA-PSS",saltLength:e.slice(-3)>>3};case"RS256":case"RS384":case"RS512":return{hash:r,name:"RSASSA-PKCS1-v1_5"};case"ES256":case"ES384":case"ES512":return{hash:r,name:"ECDSA",namedCurve:t.namedCurve};case isCloudflareWorkers()&&"EdDSA":const{namedCurve:n}=t;return{name:n,namedCurve:n};case"EdDSA":return{name:t.name};default:throw new JOSENotSupported(`alg ${e} is not supported either by JOSE or your javascript runtime`)}}function getCryptoKey(t,r,n){if(isCryptoKey(r)){checkSigCryptoKey(r,t,n);return r}if(r instanceof Uint8Array){if(!t.startsWith("HS"))throw new TypeError(invalidKeyInput(r,...o));return e.subtle.importKey("raw",r,{hash:`SHA-${t.slice(-3)}`,name:"HMAC"},false,[n])}throw new TypeError(invalidKeyInput(r,...o,"Uint8Array"))}const verify=async(t,r,n,a)=>{const i=await getCryptoKey(t,r,"verify");checkKeyLength(t,i);const o=subtleDsa(t,i.algorithm);try{return await e.subtle.verify(o,i,n,a)}catch(e){return false}};async function flattenedVerify(e,n,a){var i;if(!isObject(e))throw new JWSInvalid("Flattened JWS must be an object");if(void 0===e.protected&&void 0===e.header)throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');if(void 0!==e.protected&&"string"!==typeof e.protected)throw new JWSInvalid("JWS Protected Header incorrect type");if(void 0===e.payload)throw new JWSInvalid("JWS Payload missing");if("string"!==typeof e.signature)throw new JWSInvalid("JWS Signature missing or incorrect type");if(void 0!==e.header&&!isObject(e.header))throw new JWSInvalid("JWS Unprotected Header incorrect type");let o={};if(e.protected)try{const t=decode$1(e.protected);o=JSON.parse(r.decode(t))}catch(e){throw new JWSInvalid("JWS Protected Header is invalid")}if(!isDisjoint(o,e.header))throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const s={...o,...e.header};const c=validateCrit(JWSInvalid,new Map([["b64",true]]),null===a||void 0===a?void 0:a.crit,o,s);let d=true;if(c.has("b64")){d=o.b64;if("boolean"!==typeof d)throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean')}const{alg:l}=s;if("string"!==typeof l||!l)throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');const p=a&&validateAlgorithms("algorithms",a.algorithms);if(p&&!p.has(l))throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');if(d){if("string"!==typeof e.payload)throw new JWSInvalid("JWS Payload must be a string")}else if("string"!==typeof e.payload&&!(e.payload instanceof Uint8Array))throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");let u=false;if("function"===typeof n){n=await n(o,e);u=true}checkKeyType(l,n,"verify");const h=concat(t.encode(null!==(i=e.protected)&&void 0!==i?i:""),t.encode("."),"string"===typeof e.payload?t.encode(e.payload):e.payload);const y=decode$1(e.signature);const w=await verify(l,n,y,h);if(!w)throw new JWSSignatureVerificationFailed;let f;f=d?decode$1(e.payload):"string"===typeof e.payload?t.encode(e.payload):e.payload;const E={payload:f};void 0!==e.protected&&(E.protectedHeader=o);void 0!==e.header&&(E.unprotectedHeader=e.header);return u?{...E,key:n}:E}async function compactVerify(e,t,n){e instanceof Uint8Array&&(e=r.decode(e));if("string"!==typeof e)throw new JWSInvalid("Compact JWS must be a string or Uint8Array");const{0:a,1:i,2:o,length:s}=e.split(".");if(3!==s)throw new JWSInvalid("Invalid Compact JWS");const c=await flattenedVerify({payload:i,protected:a,signature:o},t,n);const d={payload:c.payload,protectedHeader:c.protectedHeader};return"function"===typeof t?{...d,key:c.key}:d}async function generalVerify(e,t,r){if(!isObject(e))throw new JWSInvalid("General JWS must be an object");if(!Array.isArray(e.signatures)||!e.signatures.every(isObject))throw new JWSInvalid("JWS Signatures missing or incorrect type");for(const n of e.signatures)try{return await flattenedVerify({header:n.header,payload:e.payload,protected:n.protected,signature:n.signature},t,r)}catch(e){}throw new JWSSignatureVerificationFailed}var epoch=e=>Math.floor(e.getTime()/1e3);const d=60;const l=60*d;const p=24*l;const u=7*p;const h=365.25*p;const y=/^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;var secs=e=>{const t=y.exec(e);if(!t)throw new TypeError("Invalid time period format");const r=parseFloat(t[1]);const n=t[2].toLowerCase();switch(n){case"sec":case"secs":case"second":case"seconds":case"s":return Math.round(r);case"minute":case"minutes":case"min":case"mins":case"m":return Math.round(r*d);case"hour":case"hours":case"hr":case"hrs":case"h":return Math.round(r*l);case"day":case"days":case"d":return Math.round(r*p);case"week":case"weeks":case"w":return Math.round(r*u);default:return Math.round(r*h)}};const normalizeTyp=e=>e.toLowerCase().replace(/^application\//,"");const checkAudiencePresence=(e,t)=>"string"===typeof e?t.includes(e):!!Array.isArray(e)&&t.some(Set.prototype.has.bind(new Set(e)));var jwtPayload=(e,t,n={})=>{const{typ:a}=n;if(a&&("string"!==typeof e.typ||normalizeTyp(e.typ)!==normalizeTyp(a)))throw new JWTClaimValidationFailed('unexpected "typ" JWT header value',"typ","check_failed");let i;try{i=JSON.parse(r.decode(t))}catch(e){}if(!isObject(i))throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");const{issuer:o}=n;if(o&&!(Array.isArray(o)?o:[o]).includes(i.iss))throw new JWTClaimValidationFailed('unexpected "iss" claim value',"iss","check_failed");const{subject:s}=n;if(s&&i.sub!==s)throw new JWTClaimValidationFailed('unexpected "sub" claim value',"sub","check_failed");const{audience:c}=n;if(c&&!checkAudiencePresence(i.aud,"string"===typeof c?[c]:c))throw new JWTClaimValidationFailed('unexpected "aud" claim value',"aud","check_failed");let d;switch(typeof n.clockTolerance){case"string":d=secs(n.clockTolerance);break;case"number":d=n.clockTolerance;break;case"undefined":d=0;break;default:throw new TypeError("Invalid clockTolerance option type")}const{currentDate:l}=n;const p=epoch(l||new Date);if((void 0!==i.iat||n.maxTokenAge)&&"number"!==typeof i.iat)throw new JWTClaimValidationFailed('"iat" claim must be a number',"iat","invalid");if(void 0!==i.nbf){if("number"!==typeof i.nbf)throw new JWTClaimValidationFailed('"nbf" claim must be a number',"nbf","invalid");if(i.nbf>p+d)throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed',"nbf","check_failed")}if(void 0!==i.exp){if("number"!==typeof i.exp)throw new JWTClaimValidationFailed('"exp" claim must be a number',"exp","invalid");if(i.exp<=p-d)throw new JWTExpired('"exp" claim timestamp check failed',"exp","check_failed")}if(n.maxTokenAge){const e=p-i.iat;const t="number"===typeof n.maxTokenAge?n.maxTokenAge:secs(n.maxTokenAge);if(e-d>t)throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)',"iat","check_failed");if(e<0-d)throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)',"iat","check_failed")}return i};async function jwtVerify(e,t,r){var n;const a=await compactVerify(e,t,r);if((null===(n=a.protectedHeader.crit)||void 0===n?void 0:n.includes("b64"))&&false===a.protectedHeader.b64)throw new JWTInvalid("JWTs MUST NOT use unencoded payload");const i=jwtPayload(a.protectedHeader,a.payload,r);const o={payload:i,protectedHeader:a.protectedHeader};return"function"===typeof t?{...o,key:a.key}:o}async function jwtDecrypt(e,t,r){const n=await compactDecrypt(e,t,r);const a=jwtPayload(n.protectedHeader,n.plaintext,r);const{protectedHeader:i}=n;if(void 0!==i.iss&&i.iss!==a.iss)throw new JWTClaimValidationFailed('replicated "iss" claim header parameter mismatch',"iss","mismatch");if(void 0!==i.sub&&i.sub!==a.sub)throw new JWTClaimValidationFailed('replicated "sub" claim header parameter mismatch',"sub","mismatch");if(void 0!==i.aud&&JSON.stringify(i.aud)!==JSON.stringify(a.aud))throw new JWTClaimValidationFailed('replicated "aud" claim header parameter mismatch',"aud","mismatch");const o={payload:a,protectedHeader:i};return"function"===typeof t?{...o,key:n.key}:o}class CompactEncrypt{constructor(e){this._flattened=new FlattenedEncrypt(e)}setContentEncryptionKey(e){this._flattened.setContentEncryptionKey(e);return this}setInitializationVector(e){this._flattened.setInitializationVector(e);return this}setProtectedHeader(e){this._flattened.setProtectedHeader(e);return this}setKeyManagementParameters(e){this._flattened.setKeyManagementParameters(e);return this}async encrypt(e,t){const r=await this._flattened.encrypt(e,t);return[r.protected,r.encrypted_key,r.iv,r.ciphertext,r.tag].join(".")}}const sign=async(t,r,n)=>{const a=await getCryptoKey(t,r,"sign");checkKeyLength(t,a);const i=await e.subtle.sign(subtleDsa(t,a.algorithm),a,n);return new Uint8Array(i)};class FlattenedSign{constructor(e){if(!(e instanceof Uint8Array))throw new TypeError("payload must be an instance of Uint8Array");this._payload=e}setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");this._protectedHeader=e;return this}setUnprotectedHeader(e){if(this._unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");this._unprotectedHeader=e;return this}async sign(e,n){if(!this._protectedHeader&&!this._unprotectedHeader)throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");if(!isDisjoint(this._protectedHeader,this._unprotectedHeader))throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");const a={...this._protectedHeader,...this._unprotectedHeader};const i=validateCrit(JWSInvalid,new Map([["b64",true]]),null===n||void 0===n?void 0:n.crit,this._protectedHeader,a);let o=true;if(i.has("b64")){o=this._protectedHeader.b64;if("boolean"!==typeof o)throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean')}const{alg:s}=a;if("string"!==typeof s||!s)throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');checkKeyType(s,e,"sign");let c=this._payload;o&&(c=t.encode(encode$1(c)));let d;d=this._protectedHeader?t.encode(encode$1(JSON.stringify(this._protectedHeader))):t.encode("");const l=concat(d,t.encode("."),c);const p=await sign(s,e,l);const u={signature:encode$1(p),payload:""};o&&(u.payload=r.decode(c));this._unprotectedHeader&&(u.header=this._unprotectedHeader);this._protectedHeader&&(u.protected=r.decode(d));return u}}class CompactSign{constructor(e){this._flattened=new FlattenedSign(e)}setProtectedHeader(e){this._flattened.setProtectedHeader(e);return this}async sign(e,t){const r=await this._flattened.sign(e,t);if(void 0===r.payload)throw new TypeError("use the flattened module for creating JWS with b64: false");return`${r.protected}.${r.payload}.${r.signature}`}}class IndividualSignature{constructor(e,t,r){this.parent=e;this.key=t;this.options=r}setProtectedHeader(e){if(this.protectedHeader)throw new TypeError("setProtectedHeader can only be called once");this.protectedHeader=e;return this}setUnprotectedHeader(e){if(this.unprotectedHeader)throw new TypeError("setUnprotectedHeader can only be called once");this.unprotectedHeader=e;return this}addSignature(...e){return this.parent.addSignature(...e)}sign(...e){return this.parent.sign(...e)}done(){return this.parent}}class GeneralSign{constructor(e){this._signatures=[];this._payload=e}addSignature(e,t){const r=new IndividualSignature(this,e,t);this._signatures.push(r);return r}async sign(){if(!this._signatures.length)throw new JWSInvalid("at least one signature must be added");const e={signatures:[],payload:""};for(let t=0;t<this._signatures.length;t++){const r=this._signatures[t];const n=new FlattenedSign(this._payload);n.setProtectedHeader(r.protectedHeader);n.setUnprotectedHeader(r.unprotectedHeader);const{payload:a,...i}=await n.sign(r.key,r.options);if(0===t)e.payload=a;else if(e.payload!==a)throw new JWSInvalid("inconsistent use of JWS Unencoded Payload Option (RFC7797)");e.signatures.push(i)}return e}}class ProduceJWT{constructor(e){if(!isObject(e))throw new TypeError("JWT Claims Set MUST be an object");this._payload=e}setIssuer(e){this._payload={...this._payload,iss:e};return this}setSubject(e){this._payload={...this._payload,sub:e};return this}setAudience(e){this._payload={...this._payload,aud:e};return this}setJti(e){this._payload={...this._payload,jti:e};return this}setNotBefore(e){this._payload="number"===typeof e?{...this._payload,nbf:e}:{...this._payload,nbf:epoch(new Date)+secs(e)};return this}setExpirationTime(e){this._payload="number"===typeof e?{...this._payload,exp:e}:{...this._payload,exp:epoch(new Date)+secs(e)};return this}setIssuedAt(e){this._payload="undefined"===typeof e?{...this._payload,iat:epoch(new Date)}:{...this._payload,iat:e};return this}}class SignJWT extends ProduceJWT{setProtectedHeader(e){this._protectedHeader=e;return this}async sign(e,r){var n;const a=new CompactSign(t.encode(JSON.stringify(this._payload)));a.setProtectedHeader(this._protectedHeader);if(Array.isArray(null===(n=this._protectedHeader)||void 0===n?void 0:n.crit)&&this._protectedHeader.crit.includes("b64")&&false===this._protectedHeader.b64)throw new JWTInvalid("JWTs MUST NOT use unencoded payload");return a.sign(e,r)}}class EncryptJWT extends ProduceJWT{setProtectedHeader(e){if(this._protectedHeader)throw new TypeError("setProtectedHeader can only be called once");this._protectedHeader=e;return this}setKeyManagementParameters(e){if(this._keyManagementParameters)throw new TypeError("setKeyManagementParameters can only be called once");this._keyManagementParameters=e;return this}setContentEncryptionKey(e){if(this._cek)throw new TypeError("setContentEncryptionKey can only be called once");this._cek=e;return this}setInitializationVector(e){if(this._iv)throw new TypeError("setInitializationVector can only be called once");this._iv=e;return this}replicateIssuerAsHeader(){this._replicateIssuerAsHeader=true;return this}replicateSubjectAsHeader(){this._replicateSubjectAsHeader=true;return this}replicateAudienceAsHeader(){this._replicateAudienceAsHeader=true;return this}async encrypt(e,r){const n=new CompactEncrypt(t.encode(JSON.stringify(this._payload)));this._replicateIssuerAsHeader&&(this._protectedHeader={...this._protectedHeader,iss:this._payload.iss});this._replicateSubjectAsHeader&&(this._protectedHeader={...this._protectedHeader,sub:this._payload.sub});this._replicateAudienceAsHeader&&(this._protectedHeader={...this._protectedHeader,aud:this._payload.aud});n.setProtectedHeader(this._protectedHeader);this._iv&&n.setInitializationVector(this._iv);this._cek&&n.setContentEncryptionKey(this._cek);this._keyManagementParameters&&n.setKeyManagementParameters(this._keyManagementParameters);return n.encrypt(e,r)}}const check=(e,t)=>{if("string"!==typeof e||!e)throw new JWKInvalid(`${t} missing or invalid`)};async function calculateJwkThumbprint(e,r){if(!isObject(e))throw new TypeError("JWK must be an object");null!==r&&void 0!==r?r:r="sha256";if("sha256"!==r&&"sha384"!==r&&"sha512"!==r)throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');let n;switch(e.kty){case"EC":check(e.crv,'"crv" (Curve) Parameter');check(e.x,'"x" (X Coordinate) Parameter');check(e.y,'"y" (Y Coordinate) Parameter');n={crv:e.crv,kty:e.kty,x:e.x,y:e.y};break;case"OKP":check(e.crv,'"crv" (Subtype of Key Pair) Parameter');check(e.x,'"x" (Public Key) Parameter');n={crv:e.crv,kty:e.kty,x:e.x};break;case"RSA":check(e.e,'"e" (Exponent) Parameter');check(e.n,'"n" (Modulus) Parameter');n={e:e.e,kty:e.kty,n:e.n};break;case"oct":check(e.k,'"k" (Key Value) Parameter');n={k:e.k,kty:e.kty};break;default:throw new JOSENotSupported('"kty" (Key Type) Parameter missing or unsupported')}const a=t.encode(JSON.stringify(n));return encode$1(await digest(r,a))}async function calculateJwkThumbprintUri(e,t){null!==t&&void 0!==t?t:t="sha256";const r=await calculateJwkThumbprint(e,t);return`urn:ietf:params:oauth:jwk-thumbprint:sha-${t.slice(-3)}:${r}`}async function EmbeddedJWK(e,t){const r={...e,...t.header};if(!isObject(r.jwk))throw new JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a JSON object');const n=await importJWK({...r.jwk,ext:true},r.alg,true);if(n instanceof Uint8Array||"public"!==n.type)throw new JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a public key');return n}function getKtyFromAlg(e){switch("string"===typeof e&&e.slice(0,2)){case"RS":case"PS":return"RSA";case"ES":return"EC";case"Ed":return"OKP";default:throw new JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set')}}function isJWKSLike(e){return e&&"object"===typeof e&&Array.isArray(e.keys)&&e.keys.every(isJWKLike)}function isJWKLike(e){return isObject(e)}function clone(e){return"function"===typeof structuredClone?structuredClone(e):JSON.parse(JSON.stringify(e))}class LocalJWKSet{constructor(e){this._cached=new WeakMap;if(!isJWKSLike(e))throw new JWKSInvalid("JSON Web Key Set malformed");this._jwks=clone(e)}async getKey(e,t){const{alg:r,kid:n}={...e,...t.header};const a=getKtyFromAlg(r);const i=this._jwks.keys.filter((e=>{let t=a===e.kty;t&&"string"===typeof n&&(t=n===e.kid);t&&"string"===typeof e.alg&&(t=r===e.alg);t&&"string"===typeof e.use&&(t="sig"===e.use);t&&Array.isArray(e.key_ops)&&(t=e.key_ops.includes("verify"));t&&"EdDSA"===r&&(t="Ed25519"===e.crv||"Ed448"===e.crv);if(t)switch(r){case"ES256":t="P-256"===e.crv;break;case"ES256K":t="secp256k1"===e.crv;break;case"ES384":t="P-384"===e.crv;break;case"ES512":t="P-521"===e.crv;break}return t}));const{0:o,length:s}=i;if(0===s)throw new JWKSNoMatchingKey;if(1!==s)throw new JWKSMultipleMatchingKeys;const c=this._cached.get(o)||this._cached.set(o,{}).get(o);if(void 0===c[r]){const e=await importJWK({...o,ext:true},r);if(e instanceof Uint8Array||"public"!==e.type)throw new JWKSInvalid("JSON Web Key Set members must be public keys");c[r]=e}return c[r]}}function createLocalJWKSet(e){return LocalJWKSet.prototype.getKey.bind(new LocalJWKSet(e))}const fetchJwks=async(e,t,r)=>{let n;let a;let i=false;if("function"===typeof AbortController){n=new AbortController;a=setTimeout((()=>{i=true;n.abort()}),t)}const o=await fetch(e.href,{signal:n?n.signal:void 0,redirect:"manual",headers:r.headers}).catch((e=>{if(i)throw new JWKSTimeout;throw e}));void 0!==a&&clearTimeout(a);if(200!==o.status)throw new JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");try{return await o.json()}catch(e){throw new JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON")}};class RemoteJWKSet extends LocalJWKSet{constructor(e,t){super({keys:[]});this._jwks=void 0;if(!(e instanceof URL))throw new TypeError("url must be an instance of URL");this._url=new URL(e.href);this._options={agent:null===t||void 0===t?void 0:t.agent,headers:null===t||void 0===t?void 0:t.headers};this._timeoutDuration="number"===typeof(null===t||void 0===t?void 0:t.timeoutDuration)?null===t||void 0===t?void 0:t.timeoutDuration:5e3;this._cooldownDuration="number"===typeof(null===t||void 0===t?void 0:t.cooldownDuration)?null===t||void 0===t?void 0:t.cooldownDuration:3e4;this._cacheMaxAge="number"===typeof(null===t||void 0===t?void 0:t.cacheMaxAge)?null===t||void 0===t?void 0:t.cacheMaxAge:6e5}coolingDown(){return"number"===typeof this._jwksTimestamp&&Date.now()<this._jwksTimestamp+this._cooldownDuration}fresh(){return"number"===typeof this._jwksTimestamp&&Date.now()<this._jwksTimestamp+this._cacheMaxAge}async getKey(e,t){this._jwks&&this.fresh()||await this.reload();try{return await super.getKey(e,t)}catch(r){if(r instanceof JWKSNoMatchingKey&&false===this.coolingDown()){await this.reload();return super.getKey(e,t)}throw r}}async reload(){if(this._pendingFetch&&isCloudflareWorkers())return new Promise((e=>{const isDone=()=>{void 0===this._pendingFetch?e():setTimeout(isDone,5)};isDone()}));this._pendingFetch||(this._pendingFetch=fetchJwks(this._url,this._timeoutDuration,this._options).then((e=>{if(!isJWKSLike(e))throw new JWKSInvalid("JSON Web Key Set malformed");this._jwks={keys:e.keys};this._jwksTimestamp=Date.now();this._pendingFetch=void 0})).catch((e=>{this._pendingFetch=void 0;throw e})));await this._pendingFetch}}function createRemoteJWKSet(e,t){return RemoteJWKSet.prototype.getKey.bind(new RemoteJWKSet(e,t))}class UnsecuredJWT extends ProduceJWT{encode(){const e=encode$1(JSON.stringify({alg:"none"}));const t=encode$1(JSON.stringify(this._payload));return`${e}.${t}.`}static decode(e,t){if("string"!==typeof e)throw new JWTInvalid("Unsecured JWT must be a string");const{0:n,1:a,2:i,length:o}=e.split(".");if(3!==o||""!==i)throw new JWTInvalid("Invalid Unsecured JWT");let s;try{s=JSON.parse(r.decode(decode$1(n)));if("none"!==s.alg)throw new Error}catch(e){throw new JWTInvalid("Invalid Unsecured JWT")}const c=jwtPayload(s,decode$1(a),t);return{payload:c,header:s}}}const w=encode$1;const f=decode$1;var E=Object.freeze(Object.defineProperty({__proto__:null,encode:w,decode:f},Symbol.toStringTag,{value:"Module"}));function decodeProtectedHeader(e){let t;if("string"===typeof e){const r=e.split(".");3!==r.length&&5!==r.length||([t]=r)}else if("object"===typeof e&&e){if(!("protected"in e))throw new TypeError("Token does not contain a Protected Header");t=e.protected}try{if("string"!==typeof t||!t)throw new Error;const e=JSON.parse(r.decode(f(t)));if(!isObject(e))throw new Error;return e}catch(e){throw new TypeError("Invalid Token or Protected Header formatting")}}function decodeJwt(e){if("string"!==typeof e)throw new JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");const{1:t,length:n}=e.split(".");if(5===n)throw new JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");if(3!==n)throw new JWTInvalid("Invalid JWT");if(!t)throw new JWTInvalid("JWTs must contain a payload");let a;try{a=f(t)}catch(e){throw new JWTInvalid("Failed to parse the base64url encoded payload")}let i;try{i=JSON.parse(r.decode(a))}catch(e){throw new JWTInvalid("Failed to parse the decoded payload as JSON")}if(!isObject(i))throw new JWTInvalid("Invalid JWT Claims Set");return i}async function generateSecret$1(t,r){var n;let a;let o;let s;switch(t){case"HS256":case"HS384":case"HS512":a=parseInt(t.slice(-3),10);o={name:"HMAC",hash:`SHA-${a}`,length:a};s=["sign","verify"];break;case"A128CBC-HS256":case"A192CBC-HS384":case"A256CBC-HS512":a=parseInt(t.slice(-3),10);return i(new Uint8Array(a>>3));case"A128KW":case"A192KW":case"A256KW":a=parseInt(t.slice(1,4),10);o={name:"AES-KW",length:a};s=["wrapKey","unwrapKey"];break;case"A128GCMKW":case"A192GCMKW":case"A256GCMKW":case"A128GCM":case"A192GCM":case"A256GCM":a=parseInt(t.slice(1,4),10);o={name:"AES-GCM",length:a};s=["encrypt","decrypt"];break;default:throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return e.subtle.generateKey(o,null!==(n=null===r||void 0===r?void 0:r.extractable)&&void 0!==n&&n,s)}function getModulusLengthOption(e){var t;const r=null!==(t=null===e||void 0===e?void 0:e.modulusLength)&&void 0!==t?t:2048;if("number"!==typeof r||r<2048)throw new JOSENotSupported("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");return r}async function generateKeyPair$1(t,r){var n,a,i;let o;let s;switch(t){case"PS256":case"PS384":case"PS512":o={name:"RSA-PSS",hash:`SHA-${t.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:getModulusLengthOption(r)};s=["sign","verify"];break;case"RS256":case"RS384":case"RS512":o={name:"RSASSA-PKCS1-v1_5",hash:`SHA-${t.slice(-3)}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:getModulusLengthOption(r)};s=["sign","verify"];break;case"RSA-OAEP":case"RSA-OAEP-256":case"RSA-OAEP-384":case"RSA-OAEP-512":o={name:"RSA-OAEP",hash:`SHA-${parseInt(t.slice(-3),10)||1}`,publicExponent:new Uint8Array([1,0,1]),modulusLength:getModulusLengthOption(r)};s=["decrypt","unwrapKey","encrypt","wrapKey"];break;case"ES256":o={name:"ECDSA",namedCurve:"P-256"};s=["sign","verify"];break;case"ES384":o={name:"ECDSA",namedCurve:"P-384"};s=["sign","verify"];break;case"ES512":o={name:"ECDSA",namedCurve:"P-521"};s=["sign","verify"];break;case isCloudflareWorkers()&&"EdDSA":switch(null===r||void 0===r?void 0:r.crv){case void 0:case"Ed25519":o={name:"NODE-ED25519",namedCurve:"NODE-ED25519"};s=["sign","verify"];break;default:throw new JOSENotSupported("Invalid or unsupported crv option provided")}break;case"EdDSA":s=["sign","verify"];const e=null!==(n=null===r||void 0===r?void 0:r.crv)&&void 0!==n?n:"Ed25519";switch(e){case"Ed25519":case"Ed448":o={name:e};break;default:throw new JOSENotSupported("Invalid or unsupported crv option provided")}break;case"ECDH-ES":case"ECDH-ES+A128KW":case"ECDH-ES+A192KW":case"ECDH-ES+A256KW":{s=["deriveKey","deriveBits"];const e=null!==(a=null===r||void 0===r?void 0:r.crv)&&void 0!==a?a:"P-256";switch(e){case"P-256":case"P-384":case"P-521":o={name:"ECDH",namedCurve:e};break;case"X25519":case"X448":o={name:e};break;default:throw new JOSENotSupported("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448")}break}default:throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value')}return e.subtle.generateKey(o,null!==(i=null===r||void 0===r?void 0:r.extractable)&&void 0!==i&&i,s)}async function generateKeyPair(e,t){return generateKeyPair$1(e,t)}async function generateSecret(e,t){return generateSecret$1(e,t)}export{CompactEncrypt,CompactSign,EmbeddedJWK,EncryptJWT,FlattenedEncrypt,FlattenedSign,GeneralEncrypt,GeneralSign,SignJWT,UnsecuredJWT,E as base64url,calculateJwkThumbprint,calculateJwkThumbprintUri,compactDecrypt,compactVerify,createLocalJWKSet,createRemoteJWKSet,decodeJwt,decodeProtectedHeader,a as errors,exportJWK,exportPKCS8,exportSPKI,flattenedDecrypt,flattenedVerify,generalDecrypt,generalVerify,generateKeyPair,generateSecret,importJWK,importPKCS8,importSPKI,importX509,jwtDecrypt,jwtVerify};

//# sourceMappingURL=index.js.map